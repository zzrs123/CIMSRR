# 强化学习-学习笔记5 | AlphaGo

本文不是论文阅读笔记，只是一个学习笔记，重在理解，在严谨程度上可能稍差。

AlphaGo 论文指路：

1. Mastering the game of Go with deep neural networks and tree search. Nature, 2016.https://www.nature.com/articles/nature16961
2. Mastering the game of Go without human knowledge.Nature,2017.https://www.nature.com/articles/nature24270



## 5. AlphaGo

### 5.1 围棋介绍

如果用强化学习的语言，围棋如何表达：

标准的围棋盘是一个 19 × 19 的网格，一共361个交点。State 即为一个 19 × 19 × 2 的 tensor.

> 2 的意思是 该位置的状态是 黑子/白子/空，众所周知，2位二进制可以编码 4 个状态
>
> 实际上 state 为 19  × 19 × 48 的一个 tensor，记录了更多的信息。

Action 就是在空白位置上放棋子，动作空间 $\mathbb{A}\in\{ 1,2,3,...,361\}$随着游戏的进行，action 的空间越来越小。

围棋的复杂度很高，每一步有 100余种 动作，要走上百步，所以总计可能有 $10^{170}$ 次方 种。国际象棋的“深蓝”采用的暴力搜索方法，面对围棋完全不适用，围棋的复杂度要比国际象棋高很多。



### 5.2 主要思路

训练

1. 模仿学习：从大规模的已知对局，模仿人类行为来初始化策略网络，这是一种监督学习，即多分类。
2. 策略网络：用策略梯度算法训练 Policy Network，通过两个策略网络进行对局，用胜负结果训练策略网络。
3. 价值网络：与 Actor-Critic 不同，先训练 第2步 策略网络，再用策略网络训练价值网络。



执行（与棋手对局）

- 采用蒙特卡洛树搜索 (MCTS)，不是暴力搜索，使用了 策略网络和价值网络来指导搜索。



### 5.3 策略网络

为了简单起见，采用 相对较新的 Alpha zero 论文中的策略网络进行理解。这个网络中使用了 19 × 19 ×17 的 tensor来表征状态 state。

> 解释：
>
> 19 × 19 是大小，17是矩阵的个数，把当前黑色棋子的位置用一张矩阵来表示，放置了黑子则为1，未放置为0。再用另外7张矩阵来存放前 7 步的黑子情况；总计 8 张。
>
> 同理，白子也需要 8 张。
>
> 至于为什么是 8 张，可认为是一个尝试出来的超参数。
>
> 最后一张矩阵用来表征黑白状态，如果该下黑子，则为全1矩阵，而如果该下白子，则为全0矩阵。



策略网络应该如何设计？

1个tensor表示状态，作为策略网络的输入，用 restnet 提取特征 feature，用1个或者多个全连接层，输出一个361维的向量，为了满足概率求和为，输出层的激活函数需为 softmax 。

![](D:\Downloads\image\alphago-1.png)

Alpha zero 的策略网络就是这样的思路。



### 5.4 模仿学习/初始化策略网络

这个步骤在2016的版本中出现，较新的 Alpha zero 中没有使用。

一开始，策略网络的参数是随机初始化的，如果跳过模仿学习这一步，直接进行自我博弈，agent 会做出纯随机的动作，因此需要摸索很长时间才能使行为变得稍微合理一点。这就是模仿学习这一步存在的意义。

#### a. Behavior Cloning

Behavior Cloning 不是强化学习，是一种 Imitation learning。agent 看不到奖励，也不需要奖励，只是让策略网络模仿人的动作，更泛化的讲是分类回归问题。

> 与强化学习的区别就是 没有奖励。



#### b. 训练网络

1. 观察棋盘状态 $s_t$，这是一个 tensor。
2. 把状态作为 策略网络 $\pi$ 的一个输入， $\pi$ 会输出一个361维的向量$p_t=[\pi(1|s_t,\theta),...,\pi(361|s_t,\theta)]\in(0,1)_{361}$，这个向量就是放置在361个位置每个动作的概率。
3. 而假设人类棋手真实的动作是 $a_t^*=281$，意为下在了281号位置；经过独热编码，变为一个361维的向量 $y_t$，只在第281位为1，其他全0。
4. 用Loss = CrossEntropy($y_t,p_t$) 衡量人类玩家的动作$y_t$ 和 预测 $p_t$ 之间的差异。
5. 求损失函数Loss 关于神经网络关于参数 θ 的梯度。用梯度下降来更新策略网络 θ。

> 从这个过程来讲，就是一个多分类，即有 361 个类别。这跟图像分类极其相似。







通过 behavior cloning 训练的策略网络，其实已经可以打败业余玩家了......比如当前的状态 $s_t$ 在训练数据里已经出现过了，那么策略网络就会模仿人类玩家做出预测 $a_t$ 。只要训练数据质量足够高，数量足够，就可以达到很好的下棋效果了



> 然而，Behavior Cloning 虽然容易做，但是效果不如强化学习：
>
> 即 当前状态 $s_t$ 没有出现在训练数据中的情况，这时 policy network作的动作 $a_t$ 就不会很好，并且围棋会把每一步的效果累计起来，一步怪棋，后续棋谱就更不太可能出现在从人类玩家对局中获取的训练数据中了；接着正反馈，越来越糟糕。
>
> 而围棋的情况恰恰特别多，Behavior Cloning 用到的训练数据小于全集，所以很容易失败。



### 5.5 用RL继续训练策略网络

根据 **5.4** 中最后的分析，为了应对训练数据中不存在的情况，使用强化学习继续训练策略网络，通过奖励使 agent 在某一状态下做出更合理的动作。



根据**5.2 主要思路**，AlphaGo 用两个策略网络来做博弈，一个是 **Player** / Agent，另一个是 **Opponent** / Environment，前者使用最新的模型参数，每下一局，靠奖励来更新Player的模型参数；而后者是环境，参数不需要学习，随即从旧参数中选一个出来作为策略网络的参数就可以。



#### a. Rewards

AlphaGo的奖励是这样定义的：

假设一局游戏用T步结束，在没结束的时候，每一步的奖励都是0。当游戏结束，最后一步的奖励为 +1(win)，或是 -1(lose)。

> 回想一下 回报Return 的概念：
>
> $u_t=\sum_{i=t}^Tr_i$，（不考虑折扣）

如果 agent 赢了，那么 $u_1=u_2=...=u_T=+1$；相反如果 agent 输了，$u_1=u_2=...=u_T=-1$。

即：只要赢了，认定每一步棋都好，如果输了，每一步都是臭棋。



#### b. Policy Gradient

RL步骤中用于训练策略网络的算法是策略梯度算法。

> 首先回忆一下策略梯度：
>
> 是状态价值函数 $V(s;\theta)$  关于策略网络的参数 θ 的梯度，具体的推导在强化学习笔记第三篇：https://www.cnblogs.com/Roboduster/p/16445811.html
>
> 策略梯度 =$ ∂V(s;θ)∂θ=\frac{\partial\log\pi(A|s;θ)}{\partial\theta}\cdot{Q_\pi(s,a)}$
>
> 动作价值函数定义如下：
>
> $Q_\pi(s_t,a_t)=\mathbb{E}[U_t|s_t,a_t]$，即随机变量 $U_t$ 的期望。
>
> 假如观测到了随机变量 U<sub>t</sub>的值u<sub>t</sub>，就可以拿 u<sub>t</sub> 近似 U<sub>t</sub>的期望:
>
> 策略梯度 =$ \frac{\partial{V(s;θ)}}{\partialθ}=\frac{\partial\log\pi(A|s;θ)}{\partial\theta}\cdot{u_t}$

下完一盘棋，就可以知道 u<sub>t </sub>的值，进而计算出策略梯度。



#### c. 总结概括

- 让两个策略网络下一盘棋。每下完一盘棋可以更新一次模型参数。

  > 注意 Player 的参数每局用策略梯度更新， 而Opponent 的参数每局随机从旧参数抽样。

- 得到 一个trajectory(轨迹)：$s_1,a_1,s_2,a_2...s_T,a_T$

- 有了游戏的轨迹和奖励，就能更新 Player 的策略网络：

  近似的策略梯度：$g_\theta=\sum_{t=1}^T\frac{\partial\log\pi(A|s;θ)}{\partial\theta}\cdot{u_t}$

- 策略梯度上升： $\theta_{new}\leftarrow \theta_{old}+\beta\cdot{g_\theta}$



而为了做蒙特卡洛树搜索 MCTS，还需要价值网络。



### 5.6 训练价值网络

#### a.思路介绍

与之前的价值网络不同，这里的价值网络是对 状态价值函数 V 的近似，**而不是对 Q 的近似**。

> 回顾一下状态价值函数 $V_\pi = \mathbb{E}[U_t|S_t=s]$，是回报$U_t$的条件期望。回报之前说过，取值只有+1和-1。
>
> 期望是对未来的状态 A 和未来的状态 S 求的，这样就消去除了$s_t$之外的所有随机变量。
>
> $V_\pi$ 越接近 1 ，说明快要赢了，相反越接近 -1，说明快要输了。

MCTS 需要 价值网络的辅助（近似 $V_\pi$）。



在最初版本的 AlphaGo 中，价值网络和策略网络是两个分开的神经网络。而较新的 AlphaGo Zero 让两者共享了一些卷积层 Conv。

![](D:\Downloads\image\alphago-2.png)

策略网络的输出是一个361维的向量，每个维度对应一个动作的概率；价值网络的输出是一个标量 scalar ，反映当前的胜算有多大。

策略网络和价值网络是分开训练的，首先训练策略网络 $\pi$ ，接着在策略网络的帮助下，训练 价值网络V。

> 这也是与Actor-Critic 的不同。因为A-C方法需要同时训练两个网络。



#### b.训练过程

- 还是让两个策略网络博弈，每下完一局更新网络，如果 win ，u全部等于+1，如果 lose，u全部等于-1。

  > 这一步就是用到策略网络的地方。

- 接着，类似于回归问题，Loss : $L =\sum_{t=1}^T\frac{1}{2}[v(s_t;w)-u_t]^2$

  > L 反应了 预测和真实情况的接近程度，越小说明越接近。

- 接着用 L 关于模型参数 w 求梯度，做一次梯度下降。$w\leftarrow w-\alpha\cdot\frac{\partial{L}}{\partial{w}}$



### 5.7 蒙特卡洛树搜索 MCTS

真正到了跟专业棋手下棋的时候，AlphaGo用到的既不是价值网络也不是策略网络，而是蒙特卡洛树搜索，两个神经网络只是用来帮助蒙特卡洛树搜索。

#### a. 人机下棋策略

对于人类棋手，下棋是通过多向前看几步来作出合理决策的。越是高手看的步数会越多。当年深蓝靠的就是暴力搜索所有的情况，来做出决策战胜人类的。

AlphaGo 同样是向前看，搜索未来可能发生的状态，找出胜算最大的。

#### b. 搜索思想

1. 随机选择一个动作 a，不是均匀抽样，而是按照动作的好坏程度以不同的概率选择。

   用策略函数排除掉大多数的动作（概率低的动作），这些动作不够好。

2. 接着 AlphaGo 向前看，策略网络自我博弈，直到游戏结束，根据胜负和价值函数来给动作打分。

3. 重复步骤2多次，这样每个动作都有很多个分数，累加起来或者取个期望。

4. 选择最高分数的动作 a来执行。



#### c. MCTS的步骤

有四步：

1. Selection：按照动作的分数选出一个动作（还不执行，只是为了接下来的模拟）；
2. Expansion：用策略网络模拟对手的动作，根据 $\pi$ 选一个概率较大的动作来走；
3. Evaluation：给1中选出的动作打一个分，一部分是价值网络给当前状态打一个分数 v；另一部分是策略网络自我博弈做到结束的奖励 r；把 $\frac{r+a}{2}$ 作为平均分数赋给 a。
4. Backup：$\frac{r+a}{2}$来更新动作分数。

##### (1).Selection

在当前状态 $s_t$ 的情况下，给所有动作打一个分数 score(a)，反映动作的好坏程度：

- $score(a) = Q(a)+\eta\frac{\pi(a|s;\theta)}{1+N(a)}$

> 解释：
>
> 参数方面；
>
> - Q(a)是搜索计算出来的分数，动作价值，相当于一张表，记录每个动作的分数；
> - η 是一个超参数，手动调整；
> - $\pi$ 是策略网络给动作的分数；
> - N(a)是动作 a 被选中的次数，如果动作很好，选中这一动作的可能性就很大，相应 $\pi$ 值就很大，而如果a被探索过很多次，N变大，避免重复探索过多次。
>
> 初始时Q值为0，此时完全由策略函数 $\pi$ 来决定探索哪一动作，而探索次数增加到很大之后， 第二项变小，这时主要由第一项 Q(a) 来决定。



我们举个例子继续向后理解，有三个动作，我们选择概率最大的这个$a_t$继续向下。（并不执行，只是模拟）

![](D:\Downloads\image\alphago-3.png)



##### (2).Expansion

根据策略网络模拟对手，假设把 $a_t$ 执行了，用策略函数抽样一个动作来代替对手回应。这时不是挑选概率最高的动作，所有可能的动作都有各自的概率被抽到。

> 引入一点数学概念：
>
> 状态转移函数$p(s_{t+1}|s_t,a_t)$：
>
> 对手的动作 (相当于环境 environment) 会产生新的状态 $s_{t+1}$ ，但是我们并不知道对手要怎么应对，所以不知道动作转移函数。我们使用策略函数 $\pi$ 来代替状态转移函数。

比如我们选中了概率为0.4的动作，产生了状态$s_{t+1}$：

![](D:\Downloads\image\alphago-4.png)



##### (3).Evaluation

从状态$s_{t+1}$开始，让策略网络自我博弈，直到分出胜负（Fast Rollout）。在游戏结束时拿到奖励，赢则 $r_T=+1$；输则 $r_T=-1$。

奖励 $r_T$ 被用来评价 $s_{t+1}$ 的好坏，赢了增加评分，输了减少评分。



同时，价值网络也被用来给 $s_{t+1}$ 评分，这个价值网络之前就训练好了。输入 $s_{t+1}$ ，输出评分$v(s_{t+1};w)$，也可以反映 $s_{t+1}$ 情况下的胜算有多大。



综合两个方面的评价，即 $V(s_{t+1})=\frac{1}{2}v(s_{t+1};w)+\frac{1}{2}r_T$，反映 $s_{t+1}$ 的好坏程度。

![](D:\Downloads\image\alphago-5.png)



##### (4).Backup

模拟的过程将重复很多次，所以每个状态下都会有很多记录：

![](D:\Downloads\image\alphago-6.png)

而对于每个动作 $a_t$ 都会有很多这样的子节点，对 $a_t$ 所有的记录求平均，作为 $a_t$ 新的价值 $Q(a_t)$，作为对动作 $a_t$ 的评价。

这个 Q 值就在第一步被用来选择最好的 a。



> Q值初始化为0，每搜索一次会更新一下这个 Q。
>
> 在此处可以回顾一下第一步。
>
> 当上述四步被重复很多很多次，这时候动作的 好坏 已经很明显，这样就可以做真正的对局决策了。、
>
> 一个动作 a 的 Q 值和 $\pi$ 值越大，被选中的次数N(a) 就越大，所以动作的好坏就通过 N(a) 来反映。AlphaGo就选择N值最大的动作来对局。



##### (5).对局步骤

人类棋手下一步棋，AlphaGo会重来一次蒙特卡洛树搜索，重新把 Q 和 N 初始化为0，重新进行以上四步来做模拟作决策。



### 5.8 AlphGo Zero VS AlphaGo

这部分后续补充吧，AlphaGo Zero 比 AlphaGo强大更多，主要的区别在于：

1. AlphaGo Zero 未采用 Behavior Cloning ，没有学习人类经验，反而更强。

2. 在训练策略网络的时候，就使用了 MCTS，让策略网络模仿 MCTS 做出的动作。

   > 如何使用的，后续补充。





